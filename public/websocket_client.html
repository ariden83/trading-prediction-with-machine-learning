<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Client WebSocket - Prédictions de Trading</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #2c3e50;
            margin-top: 0;
        }
        .card {
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .status {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .connected {
            background-color: #2ecc71;
        }
        .disconnected {
            background-color: #e74c3c;
        }
        .connecting {
            background-color: #f39c12;
        }
        .prediction-container {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        .prediction-card {
            width: 48%;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .prediction-up {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .prediction-down {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .prediction-neutral {
            background-color: #e2e3e5;
            border: 1px solid #d6d8db;
            color: #383d41;
        }
        .meter {
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            padding: 5px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, .2);
            position: relative;
            margin-top: 10px;
        }
        .meter > span {
            display: block;
            height: 100%;
            border-radius: 5px;
            background-color: #2ecc71;
            position: relative;
            overflow: hidden;
            transition: width 0.5s ease;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .data-table th {
            background-color: #f2f2f2;
            padding: 12px;
            text-align: left;
            border-bottom: 2px solid #ddd;
        }
        .data-table td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }
        .data-table tr:hover {
            background-color: #f5f5f5;
        }
        .timeframe-selector {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }
        .timeframe-button {
            padding: 8px 15px;
            background-color: #e0e0e0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: #555;
            transition: all 0.3s ease;
        }
        .timeframe-button:hover {
            background-color: #d0d0d0;
        }
        .timeframe-button.active {
            background-color: #2c3e50;
            color: #fff;
        }
        .log-container {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            font-family: monospace;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .log-time {
            color: #6c757d;
            margin-right: 10px;
        }
        .log-info {
            color: #007bff;
        }
        .log-error {
            color: #dc3545;
        }
        .log-success {
            color: #28a745;
        }
        .control-panel {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .control-button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .connect-button {
            background-color: #28a745;
            color: white;
        }
        .disconnect-button {
            background-color: #dc3545;
            color: white;
        }
        .send-button {
            background-color: #007bff;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Prédictions de Trading en Temps Réel</h1>
        
        <div class="card">
            <div class="status">
                <div id="statusIndicator" class="status-indicator disconnected"></div>
                <span id="statusText">Déconnecté</span>
            </div>
            
            <div class="control-panel">
                <div>
                    <input id="serverUrl" type="text" placeholder="ws://localhost:8765" value="ws://localhost:8765" style="padding: 10px; width: 200px;">
                    <button id="connectBtn" class="control-button connect-button">Connecter</button>
                    <button id="disconnectBtn" class="control-button disconnect-button" disabled>Déconnecter</button>
                </div>
                <button id="sendDataBtn" class="control-button send-button" disabled>Envoyer les données</button>
            </div>
            
            <div class="timeframe-selector">
                <button class="timeframe-button active" data-timeframe="5min">5 min</button>
                <button class="timeframe-button" data-timeframe="1h">1 h</button>
                <button class="timeframe-button" data-timeframe="4h">4 h</button>
                <button class="timeframe-button" data-timeframe="1d">1 jour</button>
            </div>
            
            <div id="predictionContainer" class="prediction-container">
                <div id="predictionCard" class="prediction-card prediction-neutral">
                    <h3>Prédiction</h3>
                    <p id="predictionText">En attente de données...</p>
                    <div class="meter">
                        <span id="confidenceMeter" style="width: 0%"></span>
                    </div>
                    <p id="confidenceText">Confiance: 0%</p>
                </div>
                
                <div class="prediction-card prediction-neutral">
                    <h3>Dernière mise à jour</h3>
                    <p id="lastUpdateTime">--</p>
                    <h3>Statistiques</h3>
                    <p>Messages reçus: <span id="messagesCount">0</span></p>
                    <p>Prédictions positives: <span id="upPredictions">0</span></p>
                    <p>Prédictions négatives: <span id="downPredictions">0</span></p>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>Historique des prédictions</h2>
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Horodatage</th>
                        <th>Prédiction</th>
                        <th>Confiance</th>
                        <th>Timeframes inclus</th>
                    </tr>
                </thead>
                <tbody id="predictionHistory">
                    <!-- Les prédictions seront ajoutées ici -->
                </tbody>
            </table>
        </div>
        
        <div class="card">
            <h2>Journal de connexion</h2>
            <div class="log-container" id="logContainer">
                <!-- Les entrées de log seront ajoutées ici -->
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let socket = null;
        let messagesCount = 0;
        let upPredictions = 0;
        let downPredictions = 0;
        let activeTimeframe = '5min';
        
        // Données OHLCV simulées pour tester
        const sampleData = {
            '5min': generateSampleData(200, '5min'),
            '1h': generateSampleData(100, '1h'),
            '4h': generateSampleData(50, '4h'),
            '1d': generateSampleData(30, '1d')
        };
        
        // Éléments DOM
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const sendDataBtn = document.getElementById('sendDataBtn');
        const serverUrlInput = document.getElementById('serverUrl');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const predictionText = document.getElementById('predictionText');
        const confidenceMeter = document.getElementById('confidenceMeter');
        const confidenceText = document.getElementById('confidenceText');
        const lastUpdateTime = document.getElementById('lastUpdateTime');
        const messagesCountElement = document.getElementById('messagesCount');
        const upPredictionsElement = document.getElementById('upPredictions');
        const downPredictionsElement = document.getElementById('downPredictions');
        const predictionHistory = document.getElementById('predictionHistory');
        const logContainer = document.getElementById('logContainer');
        const predictionCard = document.getElementById('predictionCard');
        
        // Sélecteurs de timeframe
        const timeframeButtons = document.querySelectorAll('.timeframe-button');
        
        // Initialisation
        document.addEventListener('DOMContentLoaded', () => {
            // Gérer le bouton de connexion
            connectBtn.addEventListener('click', connectToServer);
            
            // Gérer le bouton de déconnexion
            disconnectBtn.addEventListener('click', disconnectFromServer);
            
            // Gérer le bouton d'envoi de données
            sendDataBtn.addEventListener('click', sendDataToServer);
            
            // Gérer les boutons de timeframe
            timeframeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    timeframeButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    activeTimeframe = button.dataset.timeframe;
                    logMessage('info', `Timeframe actif changé pour ${activeTimeframe}`);
                });
            });
            
            // Log initial
            logMessage('info', 'Client WebSocket initialisé');
        });
        
        // Fonction pour se connecter au serveur WebSocket
        function connectToServer() {
            const serverUrl = serverUrlInput.value;
            
            try {
                // Mettre à jour l'état
                statusIndicator.className = 'status-indicator connecting';
                statusText.textContent = 'Connexion en cours...';
                logMessage('info', `Tentative de connexion à ${serverUrl}`);
                
                // Créer la connexion WebSocket
                socket = new WebSocket(serverUrl);
                
                // Gérer les événements WebSocket
                socket.onopen = handleSocketOpen;
                socket.onmessage = handleSocketMessage;
                socket.onclose = handleSocketClose;
                socket.onerror = handleSocketError;
                
                // Désactiver/activer les boutons
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
            } catch (error) {
                logMessage('error', `Erreur de connexion: ${error.message}`);
                statusIndicator.className = 'status-indicator disconnected';
                statusText.textContent = 'Erreur de connexion';
            }
        }
        
        // Fonction pour se déconnecter du serveur
        function disconnectFromServer() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.close();
                logMessage('info', 'Déconnexion manuelle du serveur');
            }
        }
        
        // Envoyer des données au serveur
        function sendDataToServer() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                // Envoyer toutes les timeframes à la fois
                sendTimeframeData('5min');
                sendTimeframeData('1h');
                sendTimeframeData('4h');
                sendTimeframeData('1d');
                
                logMessage('info', 'Données envoyées pour tous les timeframes');
                sendDataBtn.disabled = true; // Désactiver pour éviter les spam
                setTimeout(() => {
                    sendDataBtn.disabled = false;
                }, 2000);
            } else {
                logMessage('error', 'Impossible d\'envoyer les données: non connecté');
            }
        }
        
        // Envoyer les données pour un timeframe spécifique
        function sendTimeframeData(timeframe) {
            const data = {
                timeframe: timeframe,
                data: sampleData[timeframe]
            };
            
            socket.send(JSON.stringify(data));
            logMessage('info', `Données envoyées pour le timeframe ${timeframe}: ${data.data.length} barres`);
        }
        
        // Gestion des événements WebSocket
        function handleSocketOpen(event) {
            statusIndicator.className = 'status-indicator connected';
            statusText.textContent = 'Connecté';
            logMessage('success', 'Connexion établie avec le serveur');
            sendDataBtn.disabled = false;
        }
        
        function handleSocketMessage(event) {
            messagesCount++;
            messagesCountElement.textContent = messagesCount;
            
            try {
                const response = JSON.parse(event.data);
                logMessage('info', `Message reçu: ${event.data.substring(0, 100)}...`);
                
                if (response.status === 'success') {
                    updatePrediction(response);
                    addToPredictionHistory(response);
                } else {
                    logMessage('error', `Erreur du serveur: ${response.message}`);
                }
            } catch (error) {
                logMessage('error', `Erreur de traitement du message: ${error.message}`);
            }
        }
        
        function handleSocketClose(event) {
            statusIndicator.className = 'status-indicator disconnected';
            statusText.textContent = 'Déconnecté';
            logMessage('info', `Connexion fermée. Code: ${event.code}, Raison: ${event.reason}`);
            
            // Réinitialiser les boutons
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            sendDataBtn.disabled = true;
            
            // Réinitialiser le socket
            socket = null;
        }
        
        function handleSocketError(event) {
            statusIndicator.className = 'status-indicator disconnected';
            statusText.textContent = 'Erreur';
            logMessage('error', 'Erreur WebSocket');
        }
        
        // Mettre à jour l'affichage de la prédiction
        function updatePrediction(response) {
            const prediction = response.prediction[0]; // La première valeur du tableau
            const timestamp = new Date(response.timestamp);
            
            // Mettre à jour le texte de prédiction
            if (prediction > 0.5) {
                predictionText.textContent = 'HAUSSE PRÉVUE';
                predictionCard.className = 'prediction-card prediction-up';
                upPredictions++;
            } else {
                predictionText.textContent = 'BAISSE PRÉVUE';
                predictionCard.className = 'prediction-card prediction-down';
                downPredictions++;
            }
            
            // Mettre à jour le compteur de prédictions
            upPredictionsElement.textContent = upPredictions;
            downPredictionsElement.textContent = downPredictions;
            
            // Mettre à jour l'indicateur de confiance
            const confidencePercent = prediction > 0.5 ? prediction * 100 : (1 - prediction) * 100;
            confidenceMeter.style.width = `${confidencePercent}%`;
            confidenceText.textContent = `Confiance: ${confidencePercent.toFixed(2)}%`;
            
            // Mettre à jour l'horodatage
            lastUpdateTime.textContent = timestamp.toLocaleString();
        }
        
        // Ajouter une prédiction à l'historique
        function addToPredictionHistory(response) {
            const prediction = response.prediction[0];
            const timestamp = new Date(response.timestamp);
            const confidencePercent = prediction > 0.5 ? prediction * 100 : (1 - prediction) * 100;
            const direction = prediction > 0.5 ? 'HAUSSE' : 'BAISSE';
            
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${timestamp.toLocaleString()}</td>
                <td>${direction}</td>
                <td>${confidencePercent.toFixed(2)}%</td>
                <td>5min, 1h, 4h, 1d</td>
            `;
            
            predictionHistory.prepend(row);
            
            // Limiter le nombre d'éléments dans l'historique
            if (predictionHistory.children.length > 20) {
                predictionHistory.removeChild(predictionHistory.lastChild);
            }
        }
        
        // Ajouter un message au journal
        function logMessage(type, message) {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = `<span class="log-time">${timeString}</span> ${message}`;
            
            logContainer.prepend(logEntry);
            
            // Limiter le nombre d'entrées de journal
            if (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }
        
        // Générer des données OHLCV aléatoires pour tester
        function generateSampleData(count, timeframe) {
            const data = [];
            let basePrice = 100;
            let baseVolume = 1000;
            
            // Facteurs multiplicateurs en fonction du timeframe
            let priceFactor = 0.002; // 5min par défaut
            let volumeFactor = 1;
            
            switch (timeframe) {
                case '1h':
                    priceFactor = 0.005;
                    volumeFactor = 12;
                    break;
                case '4h':
                    priceFactor = 0.01;
                    volumeFactor = 48;
                    break;
                case '1d':
                    priceFactor = 0.02;
                    volumeFactor = 288;
                    break;
            }
            
            // Déterminer le pas de temps en fonction du timeframe
            let timeStep = 5 * 60 * 1000; // 5 minutes en millisecondes par défaut
            
            switch (timeframe) {
                case '1h':
                    timeStep = 60 * 60 * 1000; // 1 heure
                    break;
                case '4h':
                    timeStep = 4 * 60 * 60 * 1000; // 4 heures
                    break;
                case '1d':
                    timeStep = 24 * 60 * 60 * 1000; // 1 jour
                    break;
            }
            
            // Date de départ (il y a count * timeStep millisecondes)
            let timestamp = Date.now() - (count * timeStep);
            
            for (let i = 0; i < count; i++) {
                // Variation aléatoire du prix
                const change = (Math.random() - 0.5) * 2 * priceFactor * basePrice;
                basePrice += change;
                
                // Calculer les valeurs OHLCV
                const open = basePrice;
                const high = open * (1 + Math.random() * priceFactor);
                const low = open * (1 - Math.random() * priceFactor);
                const close = (high + low) / 2;
                const volume = Math.floor(baseVolume * (0.8 + Math.random() * 0.4) * volumeFactor);
                
                data.push({
                    timestamp: timestamp,
                    open: open,
                    high: high,
                    low: low,
                    close: close,
                    volume: volume
                });
                
                // Avancer dans le temps
                timestamp += timeStep;
            }
            
            return data;
        }
    </script>
</body>
</html>